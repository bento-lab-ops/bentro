import { boardService } from '../services/BoardService.js';
import { i18n } from '../i18n.js';
import { escapeHtml } from '../utils.js';
// import { loadBoard } from '../board.js'; // REMOVED: Using Router
import { router } from '../lib/Router.js';
window.router = router; // Expose for inline onclick handlers generated by this controller

export class DashboardController {
    constructor() {
        this.cache = [];
        this.currentFilter = 'active';
        this.containerId = 'dashboardView';
        this.templates = {};
        this.rawTemplates = {};
        this.activeFilters = new Set();
        this.initialized = false;
    }

    async init() {
        if (this.initialized) return;

        await this.loadTemplates();
        this.setupFilters();

        // Listen for language changes to update dropdown
        document.addEventListener('languageChanged', () => {
            this.populateTemplateDropdown();
            // Re-trigger change if needed, logic ported from main.js
            const select = document.getElementById('boardTemplate');
            if (select && select.value !== 'custom' && this.templates[select.value]) {
                select.dispatchEvent(new Event('change'));
            }
        });

        this.initialized = true;
    }

    async showView() {
        document.getElementById('dashboardView').style.display = 'block';
        await this.loadBoards(); // Refresh data on view show

        // Hide all other views
        const views = ['boardContainer', 'actionItemsView', 'adminView', 'teamsView', 'teamDetailsView'];
        views.forEach(id => {
            const el = document.getElementById(id);
            if (el) el.style.display = 'none';
        });

        // Reset Header Buttons
        if (document.getElementById('newBoardBtn')) document.getElementById('newBoardBtn').style.display = 'inline-block';
        if (document.getElementById('dashboardBtn')) document.getElementById('dashboardBtn').style.display = 'none';
        if (document.getElementById('leaveBoardBtn')) document.getElementById('leaveBoardBtn').style.display = 'none';

        // Update URL if not already (handled by router usually, but good for explicit switching)
        // window.location.hash = '#dashboard';
    }

    async loadBoards() {
        try {
            const boards = await boardService.getAll();
            console.log('[DashboardController] Fetched boards:', boards.length);
            this.cache = boards;
            this.filterBoards(this.currentFilter);
        } catch (error) {
            console.error('Failed to load boards:', error);
            // showToast error?
        }
    }

    filterBoards(status) {
        this.currentFilter = status;

        // UI Updates
        document.querySelectorAll('.team-nav-tab').forEach(btn => btn.classList.remove('active'));
        const activeBtn = document.getElementById(status === 'active' ? 'filterActiveBtn' : 'filterFinishedBtn');
        if (activeBtn) activeBtn.classList.add('active');

        // Filter Logic
        const filtered = this.cache.filter(b => b.status === status);
        this.renderList(filtered);
    }

    renderList(boards) {
        const grid = document.getElementById('dashboardGrid');
        if (!grid) return;

        grid.innerHTML = '';

        if (boards.length === 0) {
            const emptyState = document.getElementById('emptyDashboard');
            if (emptyState) emptyState.style.display = 'flex';
            return;
        }

        const emptyState = document.getElementById('emptyDashboard');
        if (emptyState) emptyState.style.display = 'none';

        boards.forEach(board => {
            const card = this.createBoardCard(board);
            grid.appendChild(card);
        });

        // Re-apply client-side filters if they exist (search bar)
        if (typeof window.applyDashboardFilters === 'function') {
            window.applyDashboardFilters();
        }
    }

    createBoardCard(board) {
        const card = document.createElement('div');
        card.className = 'board-card';
        card.onclick = (e) => {
            if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'I' && !e.target.closest('button')) {
                // loadBoard is currently global/legacy
                router.navigate(`board/${board.id}`);
            }
        };

        const myUser = (window.currentUser || '').toLowerCase();
        const isOwner = (board.owner || '').toLowerCase() === myUser;
        const isMember = board.participants && board.participants.some(p => (p.username || '').toLowerCase() === myUser);
        const teams = board.teams || [];
        const isTeamBoard = teams.length > 0 || !!board.team_id;

        // Display Name Logic
        let displayTeamName = board.team_name || '';
        if (teams.length > 0) {
            displayTeamName = teams.map(t => t.name).join(', ');
        }
        const hasTeam = !!displayTeamName;

        // Metadata
        const actionItemCount = board.action_item_count || 0;
        const hasActionItems = actionItemCount > 0;
        const isActive = board.status === 'active';
        const statusClass = isActive ? 'status-active' : 'status-finished';

        let deleteTitle = i18n.t('modal.delete');
        if (hasActionItems) {
            deleteTitle = i18n.t('alert.cannot_delete_items');
        } else if (isActive) {
            deleteTitle = i18n.t('alert.cannot_delete_active');
        }

        const actionItemBadge = hasActionItems
            ? `<span class="action-item-dashboard-badge" title="${actionItemCount} Action Items">âš¡ ${actionItemCount}</span>`
            : '';

        // Template Literal adapted from board.js
        card.innerHTML = `
            <div style="display:flex; justify-content:space-between; align-items:flex-start; width:100%;">
                <h3 title="${escapeHtml(board.name)}" style="text-overflow: ellipsis; overflow: hidden; white-space: nowrap; max-width: 70%;">${escapeHtml(board.name)}</h3>
                <div style="display:flex; gap:0.5rem; align-items:center;">
                    ${actionItemBadge}
                    <span class="board-status ${statusClass}">${i18n.t('status.' + board.status) || board.status}</span>
                </div>
            </div>
            
            <div class="board-meta" style="display: flex; flex-direction: column; gap: 0.5rem;">
                <div class="meta-row">
                    <span style="font-weight:600; color:var(--text-secondary); width: 80px;">${i18n.t('label.created_at') || 'Created'}:</span>
                    <span>${new Date(board.created_at).toLocaleDateString()}</span>
                </div>
                <div class="meta-row">
                    <span style="font-weight:600; color:var(--text-secondary); width: 80px;">${i18n.t('label.participants') || 'Participants'}:</span>
                    <span>${board.participant_count}</span>
                </div>
                <div class="meta-row">
                    <span style="font-weight:600; color:var(--text-secondary); width: 80px;">${i18n.t('label.owner') || 'Owner'}:</span>
                    <span>${escapeHtml(board.owner || '-')}</span>
                </div>
                ${hasTeam ? `
                <div class="meta-row">
                    <span style="font-weight:600; color:var(--text-secondary); width: 80px;">${i18n.t('label.team') || 'Team'}:</span>
                    <span title="${escapeHtml(displayTeamName)}" style="text-overflow: ellipsis; overflow: hidden; white-space: nowrap;">${escapeHtml(displayTeamName)}</span>
                </div>` : ''}
            </div>

            <div class="dashboard-actions">
                ${this.renderActions(board, isMember, isOwner)}
            </div>
        `;

        return card;
    }

    renderActions(board, isMember, isOwner) {
        let html = '';
        if (board.status === 'finished') {
            html += `<button class="btn btn-primary btn-sm" onclick="router.navigate('board/${board.id}')" title="${i18n.t('btn.view_results')}">
                        <i class="fas fa-chart-bar"></i> ${i18n.t('btn.view')}
                    </button>`;
        } else {
            if (isMember || isOwner) {
                html += `<button class="btn btn-primary btn-sm" onclick="router.navigate('board/${board.id}')" title="${i18n.t('btn.return')}">
                            <i class="fas fa-arrow-right"></i> ${i18n.t('btn.return')}
                        </button>`;
            } else {
                html += `<button class="btn btn-success btn-sm" onclick="joinBoardPersistent('${board.id}')" title="${i18n.t('btn.join')}">
                            <i class="fas fa-sign-in-alt"></i> ${i18n.t('btn.enter')}
                        </button>`;
            }
        }

        if (board.status === 'finished') {
            html += `<button class="btn btn-warning btn-sm" onclick="updateBoardStatus('${board.id}', 'active')" title="${i18n.t('btn.reopen')}"><i class="fas fa-sync-alt"></i></button>`;
            html += `<button class="btn btn-danger btn-sm" onclick="deleteBoard('${board.id}')" title="${i18n.t('modal.delete')}"><i class="fas fa-trash"></i></button>`;
        }
        return html;
    }

    async joinBoard(id) {
        if (!window.currentUser) {
            alert("Please log in to join a board.");
            return;
        }
        try {
            await boardService.join(id, {
                username: window.currentUser,
                avatar: window.currentUserAvatar
            });
            router.navigate(`board/${id}`);
        } catch (error) {
            console.error('Failed to join:', error);
            alert('Failed to join board: ' + error.message);
        }
    }

    // --- Template Logic ---
    async loadTemplates() {
        const paths = [
            `/static/board-templates.json?v=${new Date().getTime()}`,
            `/board-templates.json?v=${new Date().getTime()}`,
            `/public/board-templates.json?v=${new Date().getTime()}`
        ];

        let success = false;
        for (const path of paths) {
            try {
                const response = await fetch(path);
                if (response.ok) {
                    const templates = await response.json();
                    this.rawTemplates = templates;
                    this.templates = {};
                    for (const [key, value] of Object.entries(templates)) {
                        this.templates[key] = value.columns;
                    }
                    console.log(`[DashboardController] Templates loaded from ${path}`);
                    success = true;
                    break;
                }
            } catch (e) {
                console.warn(`Failed to load templates from ${path}`, e);
            }
        }

        if (!success) {
            console.error('[DashboardController] All template paths failed. Using defaults.');
            this.templates = {
                'start-stop-continue': ['Start Doing', 'Stop Doing', 'Continue Doing'],
                'mad-sad-glad': ['Mad ðŸ˜ ', 'Sad ðŸ˜¢', 'Glad ðŸ˜Š'],
                '4ls': ['Liked ðŸ‘', 'Learned ðŸ’¡', 'Lacked ðŸ¤”', 'Longed For ðŸŒŸ'],
                'wwn-badly-action': ['What Went Well âœ…', 'Needs Attention âš ï¸', 'Action Items ðŸŽ¯'],
                'sailboat': ['Wind ðŸ’¨', 'Anchor âš“', 'Rocks ðŸª¨', 'Island ðŸï¸']
            };
            this.rawTemplates = {};
            for (const [key, cols] of Object.entries(this.templates)) {
                this.rawTemplates[key] = { name: key, columns: cols };
            }
        }
        this.populateTemplateDropdown();
        this.bindTemplateEvents();
    }

    populateTemplateDropdown() {
        const select = document.getElementById('boardTemplate');
        if (!select) return;
        const currentSelection = select.value;
        select.innerHTML = '';

        const customOption = document.createElement('option');
        customOption.value = 'custom';
        customOption.textContent = i18n.t('template.custom') || 'Custom (Manual Entry)';
        select.appendChild(customOption);

        for (const [key, value] of Object.entries(this.rawTemplates)) {
            const option = document.createElement('option');
            option.value = key;
            const nameKey = `template.${key}.name`;
            const translatedName = i18n.t(nameKey);
            option.textContent = (translatedName && translatedName !== nameKey) ? translatedName : value.name;
            select.appendChild(option);
        }

        if (currentSelection && (this.rawTemplates[currentSelection] || currentSelection === 'custom')) {
            select.value = currentSelection;
        }
    }

    bindTemplateEvents() {
        const select = document.getElementById('boardTemplate');
        if (select) {
            // Remove old listeners? No easy way, but this init runs once.
            select.onchange = (e) => {
                const selectedValue = e.target.value;
                const columnNamesTextarea = document.getElementById('columnNames');
                if (!columnNamesTextarea) return;

                if (selectedValue === 'custom') {
                    columnNamesTextarea.value = '';
                    columnNamesTextarea.placeholder = 'Enter custom columns...';
                } else if (this.templates[selectedValue]) {
                    const templateColumns = this.templates[selectedValue];
                    if (Array.isArray(templateColumns)) {
                        // Attempt to translate each column
                        const translatedColumns = templateColumns.map((col, index) => {
                            const colKey = `template.${selectedValue}.col${index + 1}`;
                            const translated = i18n.t(colKey);
                            // If translation matches key, it means missing translation, fallback to original 'col' (which is default english)
                            return (translated && translated !== colKey) ? translated : col;
                        });
                        columnNamesTextarea.value = translatedColumns.join('\n');
                    }
                }
            };
        }
    }

    // --- Filter Logic ---
    setupFilters() {
        const searchInput = document.getElementById('boardSearchInput');
        const filterToggles = document.querySelectorAll('.filter-toggle');
        const clearBtn = document.getElementById('clearFiltersBtn');

        if (searchInput) {
            searchInput.oninput = () => this.applyFilters();
        }

        filterToggles.forEach(btn => {
            btn.onclick = () => {
                const filterType = btn.dataset.filter;
                if (this.activeFilters.has(filterType)) {
                    this.activeFilters.delete(filterType);
                    btn.classList.remove('active');
                } else {
                    this.activeFilters.add(filterType);
                    btn.classList.add('active');
                }
                this.applyFilters();
            };
        });

        if (clearBtn) {
            clearBtn.onclick = () => {
                this.activeFilters.clear();
                document.querySelectorAll('.filter-toggle').forEach(b => b.classList.remove('active'));
                if (searchInput) searchInput.value = '';
                this.applyFilters();
            };
        }
    }

    applyFilters() {
        const searchInput = document.getElementById('boardSearchInput');
        const searchText = searchInput ? searchInput.value.toLowerCase() : '';
        const cards = document.querySelectorAll('#dashboardGrid .board-card');
        let visibleCount = 0;

        const myUser = (window.currentUser || '').toLowerCase();

        cards.forEach(card => {
            let isVisible = true;
            const titleEl = card.querySelector('h3');
            const title = titleEl ? titleEl.innerText.toLowerCase() : '';
            if (searchText && !title.includes(searchText)) isVisible = false;

            if (isVisible && this.activeFilters.size > 0) {
                // DOM Parsing logic adapted
                const metaRows = card.querySelectorAll('.meta-row');
                let owner = '';
                let team = '';
                metaRows.forEach(row => {
                    const label = row.querySelector('span:first-child')?.innerText || '';
                    const value = row.querySelector('span:last-child')?.innerText || '';
                    if (label.includes('Owner') || label.includes(i18n.t('label.owner'))) owner = value.toLowerCase();
                    if (label.includes('Team') || label.includes(i18n.t('label.team'))) team = value.toLowerCase();
                });

                // Check buttons for participation status
                const hasReturnBtn = card.querySelector('.btn-primary[onclick*="view"], .btn-primary[title*="Return"], .btn-primary[onclick*="router.navigate"]');
                // Note: The logic in main.js relied on specific attributes. The renderActions in DashboardController uses onclick="router.navigate".
                // If I am member/owner, I see "Return". If not, I see "Join" (btn-success).
                const isParticipating = hasReturnBtn !== null;

                // Note: owner check might be tricky if "Me" vs "Username". 
                // renderActions uses `isOwner` passed in.

                if (this.activeFilters.has('myBoards')) {
                    // Simple check: owner name matches currentUser
                    if (owner !== myUser) isVisible = false;
                }
                if (this.activeFilters.has('participant')) {
                    if (!isParticipating) isVisible = false;
                }
                if (this.activeFilters.has('teamBoards')) {
                    if (!team || team === '-') isVisible = false;
                }
            }

            card.style.display = isVisible ? 'flex' : 'none';
            if (isVisible) visibleCount++;
        });

        // Badge Update
        const badge = document.getElementById('activeFiltersBadge');
        const countSpan = document.getElementById('activeFiltersCount');
        const clearBtn = document.getElementById('clearFiltersBtn');

        if (badge && countSpan) {
            if (this.activeFilters.size > 0) {
                badge.style.display = 'inline-flex';
                countSpan.innerText = this.activeFilters.size;
                if (clearBtn) clearBtn.style.display = 'inline-block';
            } else {
                badge.style.display = 'none';
                if (clearBtn) {
                    // Check search
                    clearBtn.style.display = searchText ? 'inline-block' : 'none';
                }
            }
        }
    }

    async handleCreateBoard(name, columns, teamId) {
        try {
            const payload = {
                name,
                columns,
                owner: window.currentUser
            };
            if (teamId) {
                payload.team_id = teamId;
            }

            const board = await boardService.create(payload);
            router.navigate(`board/${board.id}`);
            return board;
        } catch (error) {
            console.error('Failed to create board:', error);
            alert(i18n.t('alert.failed_create_board') + ': ' + error.message);
            throw error;
        }
    }
}

export const dashboardController = new DashboardController();

// Expose methods for HTML event handlers
window.filterBoards = (status) => dashboardController.filterBoards(status);
window.joinBoardPersistent = (id) => dashboardController.joinBoard(id);
// Legacy/Global function alignment
window.updateBoardStatus = async (id, status) => {
    // Re-implement or call service directly?
    // BoardController usually handles this but for dashboard actions...
    // Let's allow simple API call + reload
    try {
        await boardService.updateStatus(id, status);
        await dashboardController.loadBoards();
    } catch (e) {
        console.error(e);
        alert(e.message);
    }
};
window.deleteBoard = async (id) => {
    if (!confirm(i18n.t('confirm.delete_board'))) return;
    try {
        await boardService.delete(id);
        await dashboardController.loadBoards();
    } catch (e) {
        console.error(e);
        alert(e.message);
    }
};
